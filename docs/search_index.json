[["index.html", "A dashboard for data analysis Chapter1 Prerequisites", " A dashboard for data analysis Sanne en Jelmer 2021-01-31 Chapter1 Prerequisites Dit is ons boek! "],["introduction.html", "Chapter2 Introduction", " Chapter2 Introduction The purpose of this project wat to create a dashboard for processing and visualizing transcriptome data. The basics of the dashboard was made by Thomas Baardemans. The hardcode was capable to completly proces an GSE dataset that was saved in a text file. The project is guided by Marc Teunis. Marie Corradi joined the project later as an advisor. Our main goal was to automate the dashboard and to adapt the code so that other file types, like CSV files can be processed. The main tools for this project was the programming language R and the work environment Rstudio. R and Rstudio are created for data analysis, both are open source, free and have an active community that create new library’s, packages and functions. The software is also quite easy to use sinds both of us didn’t have any background knowledge about coding before we started the minor. A library exits out of multiple package and a package consits out of multiple functions. A function is used to achieve a specific task. The first version of the dashboard is created with R Markdown, this coding environment is used to make an active document with R. Markdown consits of a tekst format with chunks used for coding. The first version is also called the hardcode. The hardcode consists of three frameworks, knitr to create reports, markdown for the text and YAML wich is used for parameters. In the YAML stands the author, the title and extra information, here the parameters can be added. Parameters were used to automate the code. When the hardcode worked, the code was translated into a Shiny app. The R package, Shiny, makes it possible to create interactive web applications with R and Rstudio. For organising and to visualize the data, two packages from Bioconductor are really important. Bioconductor creates open source software for bioinformatics. Wich includes the packages SummarizedExperiment and DESeq2. SummarizedExperiment is used to organize and tidy up the dataset, while DESeq2 performs several calculations that are helpfull to visualize the data. "],["summary.html", "Chapter3 Summary", " Chapter3 Summary The goal of this project is too create a dashboard to analyse transcriptome data with the programming language R and the working enviroment Rstudio. Transcriptome data is usually sourced from RNA sequence experiments, Ilumina sequencing and/or microarrays. Due to the large quantity of the results it takes alot of time to research/compare the data and often a data analist is necessary to visualize the datasets. This dashboard will be a tool that a researcher can use to quickly visualize their experimental results. An application like this would be handy, because the experimental results can be easily compared. The user wouldn’t need a background in computer programming. They can enter the dataset in the app and the application will visualize the data. The application is still under construction. The goal of creating a working dashboard hasn’t been reached, but big steps into the right direction were made. An example of this is that the dashboard can almost process a CSV file. We will continue this project, this research report is created to document the made progress. "],["the-hardcode-the-beta-version-of-the-dashboard.html", "Chapter4 The hardcode - the beta version of the dashboard 4.1 Get the first data of the experiment 4.2 Untar the data. 4.3 Unzipping of the downloaded data 4.4 Make data ready for SummarizedExperiment and DESeq2 4.5 SummarizedExperiment 4.6 DESeq2 analysis", " Chapter4 The hardcode - the beta version of the dashboard Differential expression analysis This analysis used the DESeq2 workflow by Love et al., 2014(^ Love, M.I., Huber, W. &amp; Anders, S. Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2. Genome Biol 15, 550 (2014). https://doi.org/10.1186/s13059-014-0550-8) In this report we will explain every fucntion that we used o create the hardcode and the Shiny application. At the start of the project we will download serveral library's and create a root file. The processed data will be stored here. #Find the root file root &lt;- find_root_file(criterion = is_rstudio_project) 4.1 Get the first data of the experiment With the functions below the data from the selected experiment will be downloaded. The first steps are to collect the data of the experiment and the supplementary files (supp_files from now on). Inside the supp_files are the raw data of the experimnet, a supp_file can be any kind of file. For our project we've focused on csv files only. Before we can download the files we need to make a directory, this is for... . After that we need to make sure R knows what we want to work with. We can do this with PARAMS, you can find them at the top of the Rmarkdown documents. The params we use are geo_dataset(put the number of your experiemnt from NCBI_GEO (LINKJE)), params data1 and data2 will be explained later. When you want to analyze several experiments at the same time (not recommended) R needs to split the experiments, so it won't read the params as 1 experiment. We do this with the first code chunk, in this chunk, folders are also made for the (different) experiments #make a directory #create_dir &lt;- function(path) { # #} #When there are more params the (function) &quot;datasets&quot; will split them datasets &lt;- strsplit(params$geo_dataset, split = &quot; &quot;) %&gt;% unlist #With full_paths each parameter will be full_paths &lt;- file.path(here::here(), datasets) #Make maps for the different experiments inside geo_dataset purrr::walk( full_paths, dir.create) Now R knows with what kind of data we want to work with, we can download the first set of data. We do this with the function “map2” the .x tells what data to look for and .y where to put it. The function getGEO does all the magic to get the data. You might notice at .y we used full_paths, we made this directory in the last code chunk, it gives the location of the folder for each experiment. #download the data data &lt;- map2( .x = datasets, .y = full_paths, getGEO, GSEMatrix = TRUE, filename = NULL ) ## Found 1 file(s) ## GSE150646_series_matrix.txt.gz ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## .default = col_character() ## ) ## ℹ Use `spec()` for the full column specifications. ## File stored at: ## /home/jelmer_oedzes/New-eindverslag/New_new_research_project/GSE150646/GPL18694.soft With the first data, about the experiment, downloaded, it’s time to get the supp_files. We use the same map2 function from before but now with the function “getGEOSuppFiles”. This will get the supp_files from the selected experiment. #Get supp files data_supp &lt;- map2( .x = datasets, .y = full_paths, getGEOSuppFiles, makeDirectory = FALSE, #baseDir = getwd(), fetch_files = TRUE, filter_regex = NULL ) Now we’ve downloaded the experimental data (supp_files), we need to unpack them. Supp_files are often zipped or tarred, our next job is to unzip and or untar these files. First we’ll explain the untarring of files then after that the unzipping of the data. 4.2 Untar the data. To untar the data we first need to tell R where to find the tarred files. We do this with the first line of code, this contains the location of the files. We only select the tarred files with the pattern function. We tell the map function with .x where to look for the tarred data and with .f to untar these files. The last thing we tell map to do is making a new folder. We do this with exdir, this is needed because in a tarred file there are several smaller files, they need a place to go. Because the location is now different, we made an unzip function inside the untar code chunk. #To untar more files (from different geo_datasets doesn&#39;t work yet) files_tar &lt;- list.files(path = here::here(datasets), full.names = TRUE, pattern = &quot;.tar&quot;) untarr &lt;- map( .x = files_tar, .f = untar, exdir = file.path(root, params$geo_dataset , &quot;untarred&quot;) ) ## Untarred files will be unzipped ##voor nu gebruiken &quot;Probleem&quot; normaal gebruiken &gt; datasets (zonder &quot;&quot;) (weet niet meer waarom dit er staat en of het is opgelost) list_for_unzipping &lt;- list.files(file.path(root, datasets, &quot;untarred&quot;), full.names = TRUE) lapply(list_for_unzipping, gunzip) ## list() 4.3 Unzipping of the downloaded data We start the same way as “untar the data”, we tell R where to find the zipped files and select them with the pattern “.gz”. The new map function will then unzip the files with function GEOquery::gunzip files_zip &lt;- list.files(path = here::here(datasets), full.names = TRUE, pattern = &quot;.gz&quot;) unzipp &lt;- map( .x = files_zip, .f = GEOquery::gunzip ) In these first few steps we have: Downloaded supp_files and data about the experiment and unpacked these files. The next steps will be making sure the data is ready for data-analysis. 4.4 Make data ready for SummarizedExperiment and DESeq2 4.4.1 Genarating a summarized experiment for (CSV) The first steps in making a summarized experiment are getting the phenodata and metadata. Before we do that we first check if we still have the correct data selected. The glimpse(datasets) should give the same output as your selected experiment (params geo_dataset) in this case that is GSE150646. After this quick check we want to know how to get to our data and make this easier. We see that that the data is saved in a folder inside a folder. To get to the data we need to do the same function twice, that’s why we called the first one 'pre'. Now we can easily ge our data with gse_csv. #We look into the datasets to check if we have selected the experiments we want to work with. glimpse(datasets) ## chr &quot;GSE150646&quot; glimpse(data) ## List of 1 ## $ :List of 1 ## ..$ GSE150646_series_matrix.txt.gz:Formal class &#39;ExpressionSet&#39; [package &quot;Biobase&quot;] with 7 slots #To get to the data we need to do the same function twice, thats why we called the first one &#39;pre&#39; pre_gse_csv &lt;- data[[1]] gse_csv &lt;- pre_gse_csv[[1]] glimpse(gse_csv) ## Formal class &#39;ExpressionSet&#39; [package &quot;Biobase&quot;] with 7 slots ## ..@ experimentData :Formal class &#39;MIAME&#39; [package &quot;Biobase&quot;] with 13 slots ## ..@ assayData :&lt;environment: 0x5608c6547ac0&gt; ## ..@ phenoData :Formal class &#39;AnnotatedDataFrame&#39; [package &quot;Biobase&quot;] with 4 slots ## ..@ featureData :Formal class &#39;AnnotatedDataFrame&#39; [package &quot;Biobase&quot;] with 4 slots ## ..@ annotation : chr &quot;GPL18694&quot; ## ..@ protocolData :Formal class &#39;AnnotatedDataFrame&#39; [package &quot;Biobase&quot;] with 4 slots ## ..@ .__classVersion__:Formal class &#39;Versions&#39; [package &quot;Biobase&quot;] with 1 slot Now we know that we’ve the correct data and can easily access them we’ll make the phenodata and metadata. We only need 2 functions to do this, pData and experimentData. #obtaining phenotypic data. contains all the info regarding each sample. #werkt niet phenodata_csv &lt;- pData(gse_csv) %&gt;% as_tibble class(phenodata_csv) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; #metadata maken en controleren of dit klopt metadata_csv &lt;- experimentData(gse_csv) #class(metadata_csv) Now we need to “clean up” the phenodata a little bit before we can continue making a summarizedExperiment. When we look at the phenodata (with head) we see some weird names like “characteristics_ch1.1” and “characteristics_ch1.2”, these are the variables of the experiments. When you read “characteristics_ch1.1” you’ve no clue what the experiment is about, so you can change the name (for example) to gender/dev_stage/genotype etc. You can change the names with the params data1 and data2 at the start of this document. The place of “characteristics_ch1.1” can change from experiment to experiment, we haven’t find a way to automate this yet. #To look at what columm (number) the characteristics are, this can change per research, we haven&#39;t automated this yet. names(phenodata_csv) ## [1] &quot;title&quot; &quot;geo_accession&quot; ## [3] &quot;status&quot; &quot;submission_date&quot; ## [5] &quot;last_update_date&quot; &quot;type&quot; ## [7] &quot;channel_count&quot; &quot;source_name_ch1&quot; ## [9] &quot;organism_ch1&quot; &quot;characteristics_ch1&quot; ## [11] &quot;characteristics_ch1.1&quot; &quot;characteristics_ch1.2&quot; ## [13] &quot;treatment_protocol_ch1&quot; &quot;molecule_ch1&quot; ## [15] &quot;extract_protocol_ch1&quot; &quot;extract_protocol_ch1.1&quot; ## [17] &quot;extract_protocol_ch1.2&quot; &quot;taxid_ch1&quot; ## [19] &quot;data_processing&quot; &quot;data_processing.1&quot; ## [21] &quot;data_processing.2&quot; &quot;data_processing.3&quot; ## [23] &quot;platform_id&quot; &quot;contact_name&quot; ## [25] &quot;contact_email&quot; &quot;contact_department&quot; ## [27] &quot;contact_institute&quot; &quot;contact_address&quot; ## [29] &quot;contact_city&quot; &quot;contact_zip/postal_code&quot; ## [31] &quot;contact_country&quot; &quot;data_row_count&quot; ## [33] &quot;instrument_model&quot; &quot;library_selection&quot; ## [35] &quot;library_source&quot; &quot;library_strategy&quot; ## [37] &quot;relation&quot; &quot;relation.1&quot; ## [39] &quot;supplementary_file_1&quot; &quot;age:ch1&quot; ## [41] &quot;genotype:ch1&quot; &quot;strain:ch1&quot; # Het benoemen van experimentele waarde colnames(phenodata_csv)[11] &lt;- params$data1 colnames(phenodata_csv)[12] &lt;- params$data2 names(phenodata_csv) ## [1] &quot;title&quot; &quot;geo_accession&quot; ## [3] &quot;status&quot; &quot;submission_date&quot; ## [5] &quot;last_update_date&quot; &quot;type&quot; ## [7] &quot;channel_count&quot; &quot;source_name_ch1&quot; ## [9] &quot;organism_ch1&quot; &quot;characteristics_ch1&quot; ## [11] &quot;dev_stage&quot; &quot;genotype&quot; ## [13] &quot;treatment_protocol_ch1&quot; &quot;molecule_ch1&quot; ## [15] &quot;extract_protocol_ch1&quot; &quot;extract_protocol_ch1.1&quot; ## [17] &quot;extract_protocol_ch1.2&quot; &quot;taxid_ch1&quot; ## [19] &quot;data_processing&quot; &quot;data_processing.1&quot; ## [21] &quot;data_processing.2&quot; &quot;data_processing.3&quot; ## [23] &quot;platform_id&quot; &quot;contact_name&quot; ## [25] &quot;contact_email&quot; &quot;contact_department&quot; ## [27] &quot;contact_institute&quot; &quot;contact_address&quot; ## [29] &quot;contact_city&quot; &quot;contact_zip/postal_code&quot; ## [31] &quot;contact_country&quot; &quot;data_row_count&quot; ## [33] &quot;instrument_model&quot; &quot;library_selection&quot; ## [35] &quot;library_source&quot; &quot;library_strategy&quot; ## [37] &quot;relation&quot; &quot;relation.1&quot; ## [39] &quot;supplementary_file_1&quot; &quot;age:ch1&quot; ## [41] &quot;genotype:ch1&quot; &quot;strain:ch1&quot; Further change of the phnodata, needed to make Summarized Experiment. # phenodata_csv &lt;- phenodata_csv[2:41] samplenames_csv&lt;- phenodata_csv[1] 4.4.2 Last steps before SummarizedExperiment Now we can load the CSV_file, you’ll see the first few counts inside the file. Check if the data file is a “data.frame. #Load the raw data from the csv data load_csv_data &lt;- list.files(path = here::here(params$geo_dataset), full.names = TRUE, pattern = &quot;.csv&quot;) csv_data &lt;- read.csv(load_csv_data) #the first few counts of the raw data head(csv_data) ## Ensembl_geneID I16R020c01 I16R020c03 I16R020c04 I16R020c05 I16R020c06 ## 1 ENSRNOG00000040300 0 1 0 1 1 ## 2 ENSRNOG00000061316 7 5 1 6 1 ## 3 ENSRNOG00000050129 0 0 1 0 0 ## 4 ENSRNOG00000029897 0 0 0 2 0 ## 5 ENSRNOG00000042852 0 2 0 0 0 ## 6 ENSRNOG00000014303 4001 3825 3810 4494 3934 ## I16R020d01 I16R020d02 I16R020d03 I16R020d04 I16R020d06 I16R043g01 I16R043g04 ## 1 2 0 0 0 2 0 1 ## 2 1 2 1 2 2 10 6 ## 3 0 0 0 0 0 0 0 ## 4 1 1 0 2 1 1 4 ## 5 0 0 0 0 0 0 1 ## 6 4014 4167 4254 4811 4462 4406 4883 ## I16R043g05 I16R043g06 I16R043g07 I16R043h02 I16R043h03 I16R043h05 I16R043h06 ## 1 0 2 1 0 0 2 1 ## 2 2 2 6 3 4 8 7 ## 3 0 0 0 0 0 2 0 ## 4 1 2 4 5 0 5 6 ## 5 0 0 0 0 0 0 1 ## 6 5092 4935 5546 5870 5646 5316 4742 ## I16R043h07 ## 1 0 ## 2 2 ## 3 0 ## 4 4 ## 5 0 ## 6 5534 #Check if the csv_data is a data.frame class(csv_data) ## [1] &quot;data.frame&quot; In raw_counts_csv_data we load in the raw counts of the csv file, minus the first column because these are names of the samples. Also note that it can be more or less columns in different documents. In the next step we change the name of the columns to make them more understandable. The last step is to change the data.frame into a data.matrix for SummarizedExperiment. ## In het volgende stukje willen we dat de namen goed komen te staan, je ziet eerst dat het rommelig is en daarna hebben ze GSM nummers #Laat alleen de raw counts over raw_counts_csv_data &lt;- csv_data[2:21] #head(raw_counts_csv_data) ##make rowdata_csv rowdata_csv_data &lt;- raw_counts_csv_data$`Gene symbol` #Kan ik de raw_counts_csv_data gebruiken om colnames te maken test colnames(raw_counts_csv_data) &lt;-samplenames_csv[[1]] head(raw_counts_csv_data) ## GSM4555720 GSM4555721 GSM4555722 GSM4555723 GSM4555724 GSM4555725 GSM4555726 ## 1 0 1 0 1 1 2 0 ## 2 7 5 1 6 1 1 2 ## 3 0 0 1 0 0 0 0 ## 4 0 0 0 2 0 1 1 ## 5 0 2 0 0 0 0 0 ## 6 4001 3825 3810 4494 3934 4014 4167 ## GSM4555727 GSM4555728 GSM4555729 GSM4555730 GSM4555731 GSM4555732 GSM4555733 ## 1 0 0 2 0 1 0 2 ## 2 1 2 2 10 6 2 2 ## 3 0 0 0 0 0 0 0 ## 4 0 2 1 1 4 1 2 ## 5 0 0 0 0 1 0 0 ## 6 4254 4811 4462 4406 4883 5092 4935 ## GSM4555734 GSM4555735 GSM4555736 GSM4555737 GSM4555738 GSM4555739 ## 1 1 0 0 2 1 0 ## 2 6 3 4 8 7 2 ## 3 0 0 0 2 0 0 ## 4 4 5 0 5 6 4 ## 5 0 0 0 0 1 0 ## 6 5546 5870 5646 5316 4742 5534 #maak er een matrix van, weet niet waarom raw_counts_csv_data_matrix &lt;- data.matrix(raw_counts_csv_data) rownames(raw_counts_csv_data_matrix) &lt;- rowdata_csv_data #head(raw_counts_csv_data_matrix) 4.5 SummarizedExperiment SummarizedExperiment is used for organising data. This package saves rectangular matrices from experimental results. The rows represent the characteristics of interest, typically genes and transcripts. The columns stand for the samples. ColData consits of samples and metadata. Metadata is data about data, so ColData contains extra information about the samples. Here we will put a character factor in a word. The word now consits of the organised data of the raw sample data coming from the dataset. se_csv_data &lt;- SummarizedExperiment(assays = raw_counts_csv_data_matrix, rowData = rowdata_csv_data, colData = phenodata_csv) Here we will ad the metadata manually because the SummarizedExperiment won't accept it otherwise. The $ function extracts elements from a named list, by heading. metadata(se_csv_data)$metadata &lt;- metadata With the code below we will be able to inspect the SummarizedExperiment. The code &quot;head&quot; will make it possible to view the first part of the data frame. se_csv_data ## class: SummarizedExperiment ## dim: 22299 20 ## metadata(1): metadata ## assays(1): &#39;&#39; ## rownames: NULL ## rowData names(0): ## colnames(20): GSM4555720 GSM4555721 ... GSM4555738 GSM4555739 ## colData names(40): geo_accession status ... age:ch1 genotype:ch1 head(assay(se_csv_data)) ## GSM4555720 GSM4555721 GSM4555722 GSM4555723 GSM4555724 GSM4555725 ## [1,] 0 1 0 1 1 2 ## [2,] 7 5 1 6 1 1 ## [3,] 0 0 1 0 0 0 ## [4,] 0 0 0 2 0 1 ## [5,] 0 2 0 0 0 0 ## [6,] 4001 3825 3810 4494 3934 4014 ## GSM4555726 GSM4555727 GSM4555728 GSM4555729 GSM4555730 GSM4555731 ## [1,] 0 0 0 2 0 1 ## [2,] 2 1 2 2 10 6 ## [3,] 0 0 0 0 0 0 ## [4,] 1 0 2 1 1 4 ## [5,] 0 0 0 0 0 1 ## [6,] 4167 4254 4811 4462 4406 4883 ## GSM4555732 GSM4555733 GSM4555734 GSM4555735 GSM4555736 GSM4555737 ## [1,] 0 2 1 0 0 2 ## [2,] 2 2 6 3 4 8 ## [3,] 0 0 0 0 0 2 ## [4,] 1 2 4 5 0 5 ## [5,] 0 0 0 0 0 0 ## [6,] 5092 4935 5546 5870 5646 5316 ## GSM4555738 GSM4555739 ## [1,] 1 0 ## [2,] 7 2 ## [3,] 0 0 ## [4,] 6 4 ## [5,] 1 0 ## [6,] 4742 5534 4.5.1 iSEE This function can be used to explore the data stored in the SummarizedExperiment, like the row- and column-level metadata. #iSEE test #se_csv_iSEE &lt;- se_csv_data #iSEE(se_csv_iSEE) 4.6 DESeq2 analysis DESeq2 is a {package} that will be used to detect the dfference between genes and to visualize the data. The raw count data, so the raw samples, will be used as input. The code below still has to be seperated for now it doesn't work proprely with the parameters. We are looking into methods to solve this issue. This function still needs to be manually changed with processing every new dataset. The non-working code is turned off. With this function the DESeq2 dataset will be created. #condition &lt;- (get(params$data1, params$data2)) #ddsSE_csv_data &lt;- DESeq2::DESeqDataSet(se_csv_data, design = formula(~{{params$data1}}, {{params$data2}})) ddsSE_csv_data &lt;- DESeq2::DESeqDataSet(se_csv_data, design = formula(~dev_stage, genotype)) ## renaming the first element in assays to &#39;counts&#39; ## Note: levels of factors in the design contain characters other than ## letters, numbers, &#39;_&#39; and &#39;.&#39;. It is recommended (but not required) to use ## only letters, numbers, and delimiters &#39;_&#39; or &#39;.&#39;, as these are safe characters ## for column names in R. [This is a message, not an warning or error] The function rowSums returns the sums of each row in the data set. The counts function will quickly count the unique values of more variables. In the code chunck below the sums of the rows of the unique values of more variables in the DESeq2 data set are calculated. The calculated rows and the already calculated DESeq2 dataset are put in the word ddsSE_csv_data. keep &lt;- rowSums(counts(ddsSE_csv_data)) &gt;= 10 ddsSE_csv_data &lt;- ddsSE_csv_data[keep,] Below the differntial expression analysis is implemented. ddsDE_csv_data &lt;- DESeq(ddsSE_csv_data) ## estimating size factors ## Note: levels of factors in the design contain characters other than ## letters, numbers, &#39;_&#39; and &#39;.&#39;. It is recommended (but not required) to use ## only letters, numbers, and delimiters &#39;_&#39; or &#39;.&#39;, as these are safe characters ## for column names in R. [This is a message, not an warning or error] ## estimating dispersions ## gene-wise dispersion estimates ## mean-dispersion relationship ## Note: levels of factors in the design contain characters other than ## letters, numbers, &#39;_&#39; and &#39;.&#39;. It is recommended (but not required) to use ## only letters, numbers, and delimiters &#39;_&#39; or &#39;.&#39;, as these are safe characters ## for column names in R. [This is a message, not an warning or error] ## final dispersion estimates ## Note: levels of factors in the design contain characters other than ## letters, numbers, &#39;_&#39; and &#39;.&#39;. It is recommended (but not required) to use ## only letters, numbers, and delimiters &#39;_&#39; or &#39;.&#39;, as these are safe characters ## for column names in R. [This is a message, not an warning or error] ## fitting model and testing ## Note: levels of factors in the design contain characters other than ## letters, numbers, &#39;_&#39; and &#39;.&#39;. It is recommended (but not required) to use ## only letters, numbers, and delimiters &#39;_&#39; or &#39;.&#39;, as these are safe characters ## for column names in R. [This is a message, not an warning or error] ## -- replacing outliers and refitting for 12 genes ## -- DESeq argument &#39;minReplicatesForReplace&#39; = 7 ## -- original counts are preserved in counts(dds) ## estimating dispersions ## Note: levels of factors in the design contain characters other than ## letters, numbers, &#39;_&#39; and &#39;.&#39;. It is recommended (but not required) to use ## only letters, numbers, and delimiters &#39;_&#39; or &#39;.&#39;, as these are safe characters ## for column names in R. [This is a message, not an warning or error] ## fitting model and testing ## Note: levels of factors in the design contain characters other than ## letters, numbers, &#39;_&#39; and &#39;.&#39;. It is recommended (but not required) to use ## only letters, numbers, and delimiters &#39;_&#39; or &#39;.&#39;, as these are safe characters ## for column names in R. [This is a message, not an warning or error] Here the results of the analysis are transferred into the word res_csv_data. res_csv_data &lt;- results(ddsDE_csv_data) This code will show the top genes. res_csv_data[order(res_csv_data$padj), ] %&gt;% head ## log2 fold change (MLE): dev stage age..5.months vs age..12.months ## Wald test p-value: dev stage age..5.months vs age..12.months ## DataFrame with 6 rows and 6 columns ## baseMean log2FoldChange lfcSE stat ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 192.815843867977 -1.24801787212202 0.0817109121555097 -15.2735765542163 ## 2 1777.06694763123 -0.590496392470499 0.0410800783419593 -14.3742762015954 ## 3 177.261598908197 -1.65284464482474 0.121787508012539 -13.5715449950299 ## 4 1524.26391611481 -0.642772186015504 0.0477993506231875 -13.4472995476992 ## 5 539.314440529911 -0.66136608389719 0.0528648054944776 -12.5105176820574 ## 6 27.0310540415811 -4.20774212721 0.336983986487428 -12.4864750134558 ## pvalue padj ## &lt;numeric&gt; &lt;numeric&gt; ## 1 1.14705424786208e-52 2.17687955159265e-48 ## 2 7.50505673470035e-47 7.12154833555717e-43 ## 3 5.90637914529913e-42 3.73637544731623e-38 ## 4 3.19322371432675e-41 1.51502499126233e-37 ## 5 6.53966334765167e-36 2.48219462023467e-32 ## 6 8.84880714361166e-36 2.79887769952437e-32 The genes will be stored in a top 5 list for later use in the sequence alignment. top5genes &lt;- rownames(res_csv_data[order(res_csv_data$padj), ])[1:5] The log fold change will be calculated and the resultNames will be put into the LFC function. resultsNames(ddsDE_csv_data) ## [1] &quot;Intercept&quot; ## [2] &quot;dev_stage_age..5.months_vs_age..12.months&quot; We also had some problems with automating the code below, this is still a work in progress. A Log 2 fold change is apllied. resLFC_csv_data &lt;- lfcShrink(ddsDE_csv_data, coef = &quot;dev_stage_age..5.months_vs_age..12.months&quot; ) ## using &#39;normal&#39; for LFC shrinkage, the Normal prior from Love et al (2014). ## ## Note that type=&#39;apeglm&#39; and type=&#39;ashr&#39; have shown to have less bias than type=&#39;normal&#39;. ## See ?lfcShrink for more details on shrinkage type, and the DESeq2 vignette. ## Reference: https://doi.org/10.1093/bioinformatics/bty895 #coef=&quot;genotype_genotype..wildtype_vs_genotype..transgene.overexpressing.human.SNCA&quot;, type=&quot;apeglm&quot;) 4.6.1 The visualization of the dataset The code below will plot a histogram, this histogram will show the distribution of the p-values calculated by the DESeq2 analyze. ggplot(as(res_csv_data, &quot;data.frame&quot;), aes(x = pvalue)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. This code will create a volcano plot, a type of scatterplot, that will help by quickly identifying changes in the dataset. DESeq2::plotMA(resLFC_csv_data, ylim=c(-2,2)) Here a Principal Component Analysis (PCA) is created, a PCA is used to observe outliers, jumps, clusters and trends. ddsDE_rlog_csv_data &lt;- ddsDE_csv_data %&gt;% rlogTransformation() ddsDE_rlog_csv_data %&gt;% DESeq2::plotPCA(intgroup = c(params$data1 , params$data2)) + geom_vline(xintercept = 0, linetype = &quot;dashed&quot;, colour = &quot;red&quot;) + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;, colour = &quot;red&quot;) The code below creates a heatmap, this shows the extent of a phenomenon of the top 20 of up and down regulated genes as colour in two dimensions. matrix_results_csv &lt;- assay(ddsDE_rlog_csv_data) ind &lt;- matrix_results_csv %&gt;% rowMeans() %&gt;% order(decreasing = TRUE) top20 &lt;- matrix_results_csv[ind[1:20],] annot_df &lt;- as.data.frame(colData(ddsDE_csv_data)[,c(params$data1 , params$data2)]) heatmap &lt;- pheatmap(top20, scale = &quot;row&quot;, annotation_col = annot_df) heatmap "],["the-dashboard-created-with-shiny.html", "Chapter5 The dashboard created with Shiny 5.1 Download function 5.2 Downloading supfiles and untar/unzip functions. 5.3 Supplementary files download and make assaydata tab 5.4 Groupselection tab 5.5 Build summarized experiment function", " Chapter5 The dashboard created with Shiny In these chapters we'll show you the functions that we used to create the application. In the picture below you see the front page of the dashboard. knitr::include_graphics(&quot;dashboard_pictures/instructions_tab.PNG&quot;) 5.1 Download function 5.1.1 The working code behind the application. The download function is called the new download function, because we changed the orginal function to apply to different type of datasets, instead of one. The function should work for text and csv files. The code below is the function for downloading de GSE dataset. The code is &quot;split&quot; to create a loop, so the entire dataset is downloaded. With &quot;purr&quot; a map is created to store the dataset. This way the dataset can be accessed easily. The last piece of the code downloads the dataset. create_dir &lt;- function(path) {} new_download_function &lt;- function(gse_id_number) { datasets &lt;- strsplit(gse_id_number, split = &quot; &quot;) %&gt;% unlist full_paths &lt;- file.path(here::here(&quot;data&quot;), datasets) purrr::walk( full_paths, dir.create) data_1 &lt;- map2( .x = datasets, .y = full_paths, getGEO, GSEMatrix = TRUE, filename = NULL ) return(data_1) } 5.1.2 Shiny 5.1.2.1 Server.R The dataset is downloaded with the new_download function. gse_id_number &lt;- eventReactive(input$action_gse_download, { input$txt_gse_download }) gse_dataset &lt;- reactive({ new_download_function(gse_id_number()) }) The output of the contents of the GSE dataset. This shows different platforms. Below this code the phenodata of the platform choice gets loaded into a variable. output$txtout_gse_download &lt;- renderPrint(print(gse_dataset())) phenodata &lt;- eventReactive(input$action_select_platform, { gse_dataset()[[input$select_platform]] %&gt;% pData() }) output$tbl_platform_preview &lt;- DT::renderDataTable( phenodata() %&gt;% select(geo_accession, organism_ch1, characteristics_ch1, supplementary_file_1) , style = &quot;bootstrap&quot;, editable = TRUE, server = TRUE ) 5.1.2.2 UI.R The code below creates a input box for downloading the GSE number of the dataset. The box below that shows the platforms that are in the dataset. Then the platform can be selected. The last box shows a bit of the phenodata so the user can decide what platform they want to use. tabItem(tabName = &quot;download_dataset&quot;, fluidRow( box( title = &quot;GEO dataset Downloading&quot;, width = &quot;2&quot;, textInput(&quot;txt_gse_download&quot;, &quot;Enter GEO accession number. Like GSE150646.&quot;), actionButton(&quot;action_gse_download&quot;, &quot;Download this GSE dataset&quot;, icon(&quot;download&quot;, lib = &quot;font-awesome&quot;)), actionButton(&quot;action_gse_download_txt&quot;, &quot;Download this GSE dataset txt&quot;, icon(&quot;download&quot;, lib = &quot;font-awesome&quot;)) ), box( title = &quot;These platforms are in the dataset&quot;, width = &quot;10&quot;, verbatimTextOutput(&quot;txtout_gse_download&quot;) ), box( title = &quot;Select the platform you want to use for this analysis:&quot;, width = &quot;2&quot;, numericInput(&quot;select_platform&quot;, label = NULL, 1, 10, 1), actionButton(&quot;action_select_platform&quot;,&quot;load this (sub)dataset&quot;, icon(&quot;refresh&quot;)) ), box( title = &quot;Small preview of the data that is inside the platform&quot;, width = &quot;10&quot;, dataTableOutput(&quot;tbl_platform_preview&quot;) ) )) How this dashboard looks like. knitr::include_graphics(&quot;dashboard_pictures/download_dataset_tab.PNG&quot;) 5.2 Downloading supfiles and untar/unzip functions. 5.2.1 The working code behind the application. The code for downloading the supfiles is really simmilar to the download function. Only it loads the supdata, instead of the entire dataset. new_supp_download_fucntion &lt;- function(gse_id_number) { datasets &lt;- strsplit(gse_id_number, split = &quot; &quot;) %&gt;% unlist full_paths &lt;- file.path(here::here(&quot;data&quot;), datasets) data_supp &lt;- map2( .x = datasets, .y = full_paths, getGEOSuppFiles, makeDirectory = FALSE, #baseDir = getwd(), fetch_files = TRUE, filter_regex = NULL ) return(data_supp) } This is the old function that is used to unzip and untar the GSE dataset. untar_unzip_function &lt;- function(gse_id_number){ #list files that are in the supp files directory files &lt;- list.files(here::here(&quot;data&quot;, gse_id_number), full.names = TRUE) #look for .tar extension and use this value to subset the list tar_files &lt;- str_subset(files, &quot;.tar&quot;) #loop through the list and untar the files for (x in tar_files){ untar(x, exdir = file.path(here::here(&quot;data&quot;, gse_id_number))) } #remove tar files because we are done with them file.remove(tar_files) #look again at the files that are now in the directory and list them files &lt;- list.files(here::here(&quot;data&quot;, gse_id_number), full.names = TRUE) #determine what files are zipped gz_files &lt;- str_subset(files, &quot;.gz&quot;) #loop through the list and unzip the files for (x in gz_files){ gunzip(x) } filenames &lt;- list.files(here::here(&quot;data&quot;, gse_id_number)) return(filenames) } The new unzip function is created. We used this function to unzip the CSV data files. new_unzip_function &lt;- function(gse_id_number) { datasets &lt;- strsplit(gse_id_number, split = &quot; &quot;) %&gt;% unlist full_paths &lt;- file.path(here::here(&quot;data&quot;), datasets) files_zip &lt;- list.files(path = here::here(&quot;data&quot;, datasets), full.names = TRUE, pattern = &quot;.gz&quot;) unzipp &lt;- map( .x = files_zip, .f = GEOquery::gunzip ) return(files_zip) } 5.3 Supplementary files download and make assaydata tab 5.3.1 Shiny 5.3.1.1 Server.R This is the code used in the server to load the supp files and untar and unzip the data. This code isn't working proprely, one line off code is turned off, because we couldn't create a code that can load the supp files of both text files and CSV files. #Choose what data will be downloaded supp_files_csv &lt;- eventReactive(input$action_download_supp_files_csv, { new_supp_download_fucntion(gse_id_number()) }) #Show a list of supp files found in the folder output$list_of_downloaded_files &lt;- renderTable(supp_files_csv()) # output$list_of_downloaded_files &lt;- renderTable(supp_files_txt()) #Untar and unzip the dataset. observeEvent(input$action_untar_unzip_supp_files_csv, { new_unzip_function(gse_id_number()) }) observeEvent(input$action_untar_unzip_supp_files_txt, { untar_unzip_function(gse_id_number()) }) 5.3.1.2 UI.R tabItem(tabName = &quot;supp_files_assay_data&quot;, fluidRow( #select what columns to view box( title = &quot;download the supplementary files&quot;, width = &quot;10&quot;, actionButton(&quot;action_download_supp_files_csv&quot;, label = &quot;download supp files (CSV)&quot;, icon(&quot;download&quot;, lib = &quot;font-awesome&quot;)), actionButton(&quot;action_download_supp_files_tsv&quot;, label = &quot;download supp files (TSV)&quot;, icon(&quot;download&quot;, lib = &quot;font-awesome&quot;)), actionButton(&quot;action_download_supp_files_txt&quot;, label = &quot;download supp files (txt)&quot;, icon(&quot;download&quot;, lib = &quot;font-awesome&quot;)), actionButton(&quot;action_download_supp_files_etc&quot;, label = &quot;download supp files (etc)&quot;, icon(&quot;download&quot;, lib = &quot;font-awesome&quot;)) ), #show a list of supp files found in the folder box( title = &quot;Show a list of supplementary files that have been downloaded.&quot;, width = &quot;10&quot;, tableOutput(&quot;list_of_downloaded_files&quot;) ), #untar and unzip box( title = &quot;untar and unzip files&quot;, width = &quot;10&quot;, actionButton(&quot;action_untar_unzip_supp_files_csv&quot;, label = &quot;untar and unzip supp files csv&quot;, icon(&quot;download&quot;, lib = &quot;font-awesome&quot;)), actionButton(&quot;action_untar_unzip_supp_files_txt&quot;, label = &quot;untar and unzip supp files txt&quot;, icon(&quot;download&quot;, lib = &quot;font-awesome&quot;)) ), #show files that have been untarred and unzipped box( title = &quot;Show a list of supplementary files that have been unzipped.&quot;, width = &quot;10&quot;, verbatimTextOutput(&quot;list_of_untarred_files&quot;) ), #Sample selection box, this uses names of files that are in the data --&gt; &quot;GSE###### folder&quot;. The boxes that are selected will be saved to input$sample_choices. box( title = &quot;Select samples&quot;, width = &quot;3&quot;, uiOutput(&quot;sample_choices&quot;) ), fluidRow( box( width = 10, &quot;Is the sample selection box empty? This is likely due to the folder being empty at the time the GSE number was entered. To fix this simply go to the &#39;download dataset&#39; tab and click another time on the &#39;download this GSE dataset&#39; button. The sample selection boxes should now appear. To fix this problem some sort of &#39;refresh&#39; button needs to be coded but this is not very straight-forward when submitButtons can not be used.&quot; )) )) How this dashboard looks like. knitr::include_graphics(&quot;dashboard_pictures/supp_files_tab.PNG&quot;) 5.4 Groupselection tab wow hier kan je niets doen. How this dashboard looks like. knitr::include_graphics(&quot;dashboard_pictures/experimental_groups_tab.PNG&quot;) 5.5 Build summarized experiment function 5.5.1 The working code behind the application. In the code below we will create a function for building a summarized experiment. This function will be called &quot;build_summ_exp_function_csv&quot;. To begin we will create the phenodata. The the colnames are then created by seperating the different characteristics of the dataset. By line 33 there is a path created where the data will be stored on the server. Here you can also see that the code is created for csv files. For furher research we will only need the raw counts from the dataset. These are isolated. At the end the metadata is created. The function return() wil return the results. build_summ_exp_function_csv &lt;-function(gse_id_number){ phenodata_data &lt;- getGEO(gse_id_number) phenodata_tbl &lt;- map_df(phenodata_data, pData) %&gt;% as_tibble() colnames(phenodata_tbl)[11] &lt;- &quot;dev_stage&quot; colnames(phenodata_tbl)[12] &lt;- &quot;genotype&quot; phenodata_csv &lt;- phenodata_tbl[2:41] samplenames_csv&lt;- phenodata_tbl[1] load_csv_data &lt;- list.files(path = here::here(&quot;data&quot;, gse_id_number), full.names = TRUE, pattern = &quot;.csv&quot;) csv_data &lt;- read.csv(load_csv_data) raw_counts_csv_data &lt;- csv_data[2:21] raw_counts_csv_data_matrix &lt;- data.matrix(raw_counts_csv_data) rowdata_csv_data &lt;- raw_counts_csv_data$`Gene symbol` rownames(raw_counts_csv_data_matrix) &lt;- rowdata_csv_data colnames(raw_counts_csv_data) &lt;-samplenames_csv[[1]] se &lt;- SummarizedExperiment(assays = raw_counts_csv_data_matrix, rowData = rowdata_csv_data, colData = phenodata_csv) metadata(se)$metadata &lt;- metadata return(se) } 5.5.2 Shiny 5.5.2.1 Server.R In the code below from the server, the created function for summarized experiment is used. The output of the code below is the assay data (raw counts) from the dataset. We renamed se to se_2, because the code wouldn't work if the name was the same as the se name in the function. se_2 &lt;- eventReactive(input$build_sum_csv, { build_summ_exp_function_csv(gse_id_number()) }) output$tbl_assaydata_preview &lt;- DT::renderDataTable( SummarizedExperiment::assay(se_2()), style = &quot;bootstrap&quot;, server = TRUE) 5.5.2.2 ui.R Below is the code for the tab that contains the summarized experiment. The checkboxGroupInput is turned off, because this wasn't working probaly. We wanted to add this in so that the user can change the chosen names. The last box shows the selected colnames of the phenodata. tabItem(tabName = &quot;build_summarized_experiment&quot;, verticalLayout( box( title = &quot;Make a summarizedExperiment&quot;, width = &quot;10&quot;, #actionButton(&quot;setup_se&quot;, label = &quot;setup for summerizedExperiment&quot;, icon(&quot;download&quot;, lib = &quot;font-awesome&quot;)), #build experiment #checkboxGroupInput(&quot;sample_choises&quot;, &quot;selected_samples&quot;), #textInput(&quot;test_selected&quot;, &quot;Enter a copy of the sample_choises you want to test.&quot;), actionButton(&quot;build_sum_csv&quot;, &quot;build se from csv&quot;, icon = icon(&quot;wrench&quot;, lib = &quot;font-awesome&quot;)), actionButton(&quot;build_sum_txt&quot;, &quot;build se from txt&quot;, icon = icon(&quot;wrench&quot;, lib = &quot;font-awesome&quot;)), box( title = &quot;Preview of the assaydata of this summarized experiment&quot;, width = &quot;12&quot;, dataTableOutput(&quot;tbl_assaydata_preview&quot;) ) ))) How this dashboard looks like. knitr::include_graphics(&quot;dashboard_pictures/SE_tab.PNG&quot;) 5.5.2.3 Deseq2 function 5.5.3 Make DESeq2 tab This page is quite simple, we make a box where the data will be rendered. With an actionbutton the user will be able to activate the &quot;deseq2_function&quot; How this dashboard looks like. knitr::include_graphics(&quot;dashboard_pictures/Deseq2_tab.PNG&quot;) 5.5.4 Figures Inside the figure tab we need to make boxes so the figures have a place to go, we also have to make an actionbutton so only the figures you want will be displayed. For now this doesn't work. Pressing one button will give you all the figures. This will give a long loading time, so we want to add a loading barr. #figures tab UI tabItem(tabName = &quot;make_figures&quot;, fluidRow( box( title = &quot;PCA&quot;, width = &quot;10&quot;, actionButton(&quot;calculate_PCA&quot;, &quot;First examples of PCA&quot;), box( title = &quot;First examples of PC analysis&quot;, width = &quot;12&quot;, plotOutput(&quot;matrix_PCA&quot;) )), box( title = &quot;Heatmap&quot;, width = &quot;10&quot;, actionButton(&quot;calculate_heatmap&quot;, &quot;Heatmap top 20&quot;), box( title = &quot;heatmap&quot;, width = &quot;12&quot;, plotOutput(&quot;matrix_heatmap&quot;) )), box( title = &quot;Histogram&quot;, width = &quot;10&quot;, actionButton(&quot;calculate_histogram&quot;, &quot;histogram&quot;), box( title = &quot;This is a Histogram&quot;, width = &quot;12&quot;, plotOutput(&quot;matrix_Histogram&quot;) )), box( title = &quot;Vulcan plot&quot;, width = &quot;10&quot;, actionButton(&quot;calculate_Vulcan&quot;, &quot;Vulcan&quot;), box( title = &quot;This is a Vulcan plot&quot;, width = &quot;12&quot;, plotOutput(&quot;matrix_Vulcan&quot;) )) )) #figures tab server #PCA plot maken pca_plot &lt;- eventReactive(input$calculate_PCA, { pca_function(se_input = se_2()) }) output$matrix_PCA &lt;- renderPlot ({ pca_function(se_input = se_2()) }) #Heatmap maken heatmap_plot &lt;- eventReactive(input$calculate_heatmap, { heatmap_function(se_input = se_2()) }) output$matrix_heatmap &lt;- renderPlot ({ heatmap_function(se_input = se_2()) }) #Histogram histogram_plot &lt;- eventReactive(input$calculate_histogram, { geom_histogram_function(se_input = se_2()) }) output$matrix_Histogram &lt;- renderPlot ({ geom_histogram_function(se_input = se_2()) }) #Vulcan vulcan_plot &lt;- eventReactive(input$calculate_Vulcan, { vulcan_function(se_input = se_2()) }) output$matrix_Vulcan &lt;- renderPlot ({ vulcan_function(se_input = se_2()) }) How the PCA looks like. knitr::include_graphics(&quot;dashboard_pictures/PCA_tab.PNG&quot;) How the heatmap looks like. knitr::include_graphics(&quot;dashboard_pictures/heatmap_tab.PNG&quot;) How the histogram looks like. knitr::include_graphics(&quot;dashboard_pictures/Histogram_tab.PNG&quot;) How the vulcan plot looks like. knitr::include_graphics(&quot;dashboard_pictures/vulcan_plot.PNG&quot;) 5.5.4.1 PCA function #PCA fucntion pca_function &lt;- function(se_input){ #We need to do the first steps of the DESeq2 again, we are looking for a solution to make this easier ddsSE &lt;- DESeq2::DESeqDataSet(se_input, design = formula(~dev_stage + genotype)) #ddsSE &lt;- DESeq2::DESeqDataSet(se, design = formula(~dev_stage + infection_genotype)) keep &lt;- rowSums(counts(ddsSE)) &gt;= 10 ddsSE &lt;- ddsSE[keep,] ddsDE &lt;- DESeq(ddsSE) ddsDE_rlog &lt;- ddsDE %&gt;% rlogTransformation() #Make the pca_plot,, dev_stage and genotype needs to be params pca_plot &lt;- ddsDE_rlog %&gt;% DESeq2::plotPCA(intgroup = c(&quot;dev_stage&quot;, &quot;genotype&quot;)) + geom_vline(xintercept = 0, linetype = &quot;dashed&quot;, colour = &quot;red&quot;) + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;, colour = &quot;red&quot;) return(pca_plot) } 5.5.4.2 Make PCA figure tabItem(tabName = &quot;make_figures&quot;, fluidRow( box( title = &quot;PCA&quot;, width = &quot;10&quot;, actionButton(&quot;calculate_PCA&quot;, &quot;First examples of PCA&quot;) #PCA plot maken pca_plot &lt;- eventReactive(input$calculate_PCA, { pca_function(se_input = se_2()) }) output$matrix_PCA &lt;- renderPlot ({ pca_function(se_input = se_2()) }) How this dashboard looks like. knitr::include_graphics(&quot;dashboard_pictures/download_tab.PNG&quot;) 5.5.4.3 Heatmap function heatmap_function &lt;- function(se_input){ #First part is the deseq2 function again ddsSE &lt;- DESeq2::DESeqDataSet(se_input, design = formula(~dev_stage + genotype)) keep &lt;- rowSums(counts(ddsSE)) &gt;= 10 ddsSE &lt;- ddsSE[keep,] ddsDE &lt;- DESeq(ddsSE) ddsDE_rlog &lt;- ddsDE %&gt;% rlogTransformation() matrix_results &lt;- assay(ddsDE_rlog) ind &lt;- matrix_results %&gt;% rowMeans() %&gt;% order(decreasing = TRUE) top20 &lt;- matrix_results[ind[1:20],] annot_df &lt;- as.data.frame(colData(ddsDE)[,c(&quot;dev_stage&quot;,&quot;genotype&quot;)]) heatmap &lt;- pheatmap(top20, scale = &quot;row&quot;, annotation_col = annot_df) return(heatmap) } 5.5.4.4 Make heatmap figure of top 20 box( title = &quot;Heatmap&quot;, width = &quot;10&quot;, actionButton(&quot;calculate_heatmap&quot;, &quot;Heatmap top 20&quot;), box( title = &quot;heatmap&quot;, width = &quot;12&quot;, plotOutput(&quot;matrix_heatmap&quot;) )) #Heatmap maken heatmap_plot &lt;- eventReactive(input$calculate_heatmap, { heatmap_function(se_input = se_2()) }) output$matrix_heatmap &lt;- renderPlot ({ heatmap_function(se_input = se_2()) }) 5.5.4.5 Histogram code geom_histogram_function &lt;- function(se_input) { #We need to do the first steps of the DESeq2 again, we are looking for a solution to make this easier ddsSE &lt;- DESeq2::DESeqDataSet(se_input, design = formula(~dev_stage + genotype)) #ddsSE &lt;- DESeq2::DESeqDataSet(se, design = formula(~dev_stage + genotype)) keep &lt;- rowSums(counts(ddsSE)) &gt;= 10 ddsSE &lt;- ddsSE[keep,] #run differential expression analysis ddsDE&lt;- DESeq(ddsSE) #Results res &lt;- results(ddsDE) head_res &lt;- res[order(res$padj), ] %&gt;% head # show distribution of p-values Histogram_iets &lt;-ggplot(as(head_res, &quot;data.frame&quot;), aes(x = pvalue)) + geom_histogram() return(Histogram_iets) } # 5.5.4.6 Make histogram figure box( title = &quot;Histogram&quot;, width = &quot;10&quot;, actionButton(&quot;calculate_histogram&quot;, &quot;histogram&quot;), box( title = &quot;This is a Histogram&quot;, width = &quot;12&quot;, plotOutput(&quot;matrix_Histogram&quot;) )) #Histogram histogram_plot &lt;- eventReactive(input$calculate_histogram, { geom_histogram_function(se_input = se_2()) }) output$matrix_Histogram &lt;- renderPlot ({ geom_histogram_function(se_input = se_2()) }) 5.5.4.7 Vulcan plot code vulcan_function &lt;-function(se_input) { ddsSE &lt;- DESeq2::DESeqDataSet(se_input, design = formula(~dev_stage + genotype)) #ddsSE &lt;- DESeq2::DESeqDataSet(se, design = formula(~dev_stage + genotype)) keep &lt;- rowSums(counts(ddsSE)) &gt;= 10 ddsSE &lt;- ddsSE[keep,] #run differential expression analysis ddsDE&lt;- DESeq(ddsSE) #Results res &lt;- results(ddsDE) head_res &lt;- res[order(res$padj), ] %&gt;% head top5genes &lt;- rownames(res[order(res$padj), ])[1:5] resLFC &lt;- lfcShrink(ddsDE, coef = &quot;dev_stage_age..5.months_vs_age..12.months&quot; ) Vulcan_iets &lt;-DESeq2::plotMA(resLFC, ylim=c(-2,2)) return(Vulcan_iets) } 5.5.4.8 Make vulcan plot box( title = &quot;Vulcan plot&quot;, width = &quot;10&quot;, actionButton(&quot;calculate_Vulcan&quot;, &quot;Vulcan&quot;), box( title = &quot;This is a Vulcan plot&quot;, width = &quot;12&quot;, plotOutput(&quot;matrix_Vulcan&quot;) )) #Vulcan vulcan_plot &lt;- eventReactive(input$calculate_Vulcan, { vulcan_function(se_input = se_2()) }) output$matrix_Vulcan &lt;- renderPlot ({ vulcan_function(se_input = se_2()) }) 5.5.5 Download data tab We want to be able to download the data, this doesn't work yet. "],["conclusion.html", "Chapter6 Conclusion", " Chapter6 Conclusion Our goal was to make a working dashboard for analyzing transcriptome data. So far we made a dashboard that can analyze csv files. And automated this as far as we can. But if you want to use a different csv file you’ll need to change some of the functions. In the discussion we describe the parts. "],["discussion-recommendations.html", "Chapter7 Discussion &amp; recommendations 7.1 Functions that needs to be changed every time. 7.2 Recommendations", " Chapter7 Discussion &amp; recommendations 7.1 Functions that needs to be changed every time. (op volgorde zetten) build_summ_function_csv.R The first thing you need to check, what’s the column number of the variable factor row 30 and 31: colnames(phenodata_tbl)[11] &lt;- &quot;dev_stage&quot; colnames(phenodata_tbl)[12] &lt;- &quot;genotype&quot; How big is the phenodata_tbl? phenodata_csv &lt;- phenodata_tbl[2:41] How big is the csv file (how many columns?) raw_counts_csv_data &lt;- csv_data[2:21] geom_histogram_function.R Change the variable factor on row 4 ddsSE &lt;- DESeq2::DESeqDataSet(se_input, design = formula(~dev_stage + genotype)) heatmap_function.R Change the variable factor on row 4 and 24 ddsSE &lt;- DESeq2::DESeqDataSet(se_input, design = formula(~dev_stage + genotype)) annot_df &lt;- as.data.frame(colData(ddsDE)[,c(&quot;dev_stage&quot;,&quot;genotype&quot;)]) pca_function.R Change the variable factor on row 4 and 19 ddsSE &lt;- DESeq2::DESeqDataSet(se_input, design = formula(~dev_stage + genotype)) DESeq2::plotPCA(intgroup = c(&quot;dev_stage&quot;, &quot;genotype&quot;)) pca_function.R Change the variable factor on row 4 and 17/18 ddsSE &lt;- DESeq2::DESeqDataSet(se_input, design = formula(~dev_stage + genotype)) resLFC &lt;- lfcShrink(ddsDE, coef = &quot;dev_stage_age..5.months_vs_age..12.months&quot; ) 7.2 Recommendations We want to make more functions and buttons for the dashboard. What we’ve in mind: For different formats (xlsx, txt, etc) we make different functions. For each format we research what kind of codes match, so we can make a ‘work flow’ for the different formats. This should make the dashboard faster. Inside the dashboard you can press the action buttons with these functions. What we’d also like to test, the user can select at the first page of the dashboard what kind of files they want to work with. If they select csv files, the action buttons will automatically choose the csv functions. In the experimental group tab we want to be able to select 2 characteristic(s) and change their name. The dashboard will work with these selected (…) this change would automate a big part of the code and the dashboard. The figure tab doesn’t work like it should. It automatically makes all the figures instead of one. Because of this we want to add a loading bar so the user knows the dashboard is still working. The download your data tab doesn’t work at all. We want to make a checkbox group where you can select what kind of data you want to download and in what kind of format. test commit "]]
